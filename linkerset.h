/* BSD 2-Clause License
 *
 * Copyright (c) 2025 Logic Magicians Software (Taylor Hutt)
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 *
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 *
 * 2. Redistributions in binary form must reproduce the above
 *    copyright notice, this list of conditions and the following
 *    disclaimer in the documentation and/or other materials provided
 *    with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
 * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
 * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS
 * FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE
 * COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT,
 * INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
 * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
 * SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,
 * STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
 * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED
 * OF THE POSSIBILITY OF SUCH DAMAGE.
 */
#if !defined(_LINKERSET_H_)
#define _LINKERSET_H_
#include <stdlib.h>

#if defined(__GNUC__)
#define WEAK_ __attribute__((weak))
#else
#error Unrecognized compiler; no WEAK_ definition.
#endif

#define CONCAT_(_a, _b) _a##_b
#define XCONCAT_(_a, _b) CONCAT_(_a, _b)
#define STRING_(x)       #x        /* Stringify 'x'. */
#define XSTRING_(x)      STRING_(x) /* Expand 'x', then stringify. */

/* LINKERSET
 *
 *   A linkerset is a collection of unordered pointers that is bounded
 *   by a 'start' and 'stop.  The 'stop' and 'start' symbols are
 *   automatically created by the Gnu Linker, and form an open-ended
 *   bounded by [start, stop).  The memory referenced by the pointers
 *   in the [start, stop) range will refer to data generated by your
 *   program.
 *
 *   Linkersets can be used, for example, for the following:
 *
 *     o A list of initialization functions that correspond to modules
 *       that have been linked into the program.
 *
 *     o A list of finalization functions that must be executed at
 *       program termination.  The contents will be based on what
 *       modules have been linked into the program.
 *
 *     o Pre-allocation memory requirements for various aspects of a
 *       system.  During program startup, processing the linkerset
 *       would allocate the memory necessary.
 *
 *     o To automatically start a set of threads that is dependent on
 *       what is linked into the final program.
 *
 *   The operations supported by a linkerset are:
 *
 *     o Declaration (compile time).
 *
 *       A linkerset, and its name,must be declared before use.  See
 *       LINKERSET_DECLARE.
 *
 *       The declaration names the linkerset.  The name of the
 *       linkerset must have a corresponding type with '_t' as a
 *       suffix.  For example, if
 *
 *         LINKERSET_DECLARE(linkerset)
 *
 *       is used, there must be a C type named 'linkerset_t'.
 *       Generally this data type is used to hold the actual data to
 *       be grouped together in the linkerset.  For example, a set of
 *       functions used to start threads, or a collection of devices
 *       that are to be supported.
 *
 *       NOTE: Linkersets are based on C type names.  The result of
 *             declaring multiple linkersets using same-name, yet
 *             different C types, is undefined.  This would be
 *             possible in different C source files, where the same
 *             type name is used, but those C types have different
 *             structures.  At link time, they contents of all
 *             same-named linkersets will be collated into a single
 *             section.
 *
 *     o Add elements (compile time).
 *
 *       Data is added to a linkerset with LINKERSET_ADD_ITEM.
 *
 *       All data stored in a linkerset will be a pointer to the C
 *       data structure implied via LINKERSET_DECLARE().
 *
 *       The elements added to the linkerset will be collated by the
 *       linker.  The linkerset will be contained in a specially-named
 *       data section (the name is managed by this linkerset module,
 *       and is not material to its use).
 *
 *       Only elements added to the linkerset that are actually linked
 *       into the program will be present in the final executable.
 *       This is made possible because the symbols are marked as
 *       'weak'.
 *
 *       NOTE: A linkerset that has no data added, or for which
 *             nothing is linked will have zero (0) elements at run
 *             time.
 *
 *     o Iterate over elements in a linkerset (run time).
 *
 *       LINKERSET_ITERATE allows one to visit every element in the
 *       linkerset.
 *
 *     o Determine number of elements in linkerset (run time).
 *
 *       While rarely needed outside of this header, it's possible to
 *       determine the number of elements in a linkerset with
 *       LINKERSET_SIZE().
 *
 *     o Sort elements (run time).
 *
 *       By definition a linkerset is unordered, but it can be brought
 *       into an order of your choosing using LINKERSET_SORT().  The
 *       pointers contained in the linkerset are sorted in-place.
 *
 *  Here's how a linkerset may look in memory:
 *
 *    header.h:   struct example_t {
 *                    unsigned v;
 *                };
 *
 *    a.c     :   example_t data_0;
 *                LINKERSET_ADD_ITEM(example, data_0);
 *
 *    b.c     :   example_t data_1;
 *                LINKERSET_ADD_ITEM(example, data_1);
 *
 *   memory layout
 *                .bss:
 *                            <data>
 *                    data_0:
 *                            <data_0 data>
 *                            ...
 *                            <more, unrelated, data>
 *                            ...
 *                    data_1:
 *                            <data_1 data>
 *
 *                 __start_example:
 *                       &data_1
 *                       &data_0
 *                 __stop_example
 *
 *   Notice that the ordering of the data in the linkerset --
 *   [__start_example, __stop_example)) -- is not ordered in the same
 *   way as the data in the .bss section, nor as implied by the
 *   ordering of the C files.
 *
 *   Both the linkerset and the associated data are regular R/W data.
 */


/* LINKERSET_START, LINKERSET_END
 *
 *  These symbols produce the address of the linker-generated,
 *  region-bounding, [start, stop) symbols.
 */
#define LINKERSET_START(_name)                  \
    XCONCAT_(&__start_, _name)

#define LINKERSET_STOP(_name)                   \
    XCONCAT_(&__stop_, _name)


/* LINKERSET_DECLARE: Enable access to a linkerset in a source file.
 *
 * The __start_<name> & __stop_<name> symbols are generated
 * automatically by the linker, but they are not marked as global.
 * Without otherwise being marked as global, the symbols will not be
 * accessible to the C code generated by these macros.
 *
 * This automatic [start, stop)-symbol generation is a special feature
 * that only applies to sections which are named with names that are C
 * identifiers; '.<section-name>'-style names will not cause this
 * symbol generation feature to occur.
 */
#define LINKERSET_DECLARE(_name)                                        \
    extern XCONCAT_(_name, _t) WEAK_ *XCONCAT_(__start_, _name);        \
    extern XCONCAT_(_name, _t) WEAK_ *XCONCAT_(__stop_, _name);         \
    __asm__(".global __start_" XSTRING_(_name));                        \
    __asm__(".global __stop_" XSTRING_(_name))


/* LINKERSET_ADD_ITEM: Add an item to a linkerset.
 *
 *  _name     : The name of a linkerset used with LINKERSET_DECLARE().
 *
 *  _desc_name: The name of the variable which should be referenced by
 *              the linkerset entry.  This variable should be given the C type
 *              implied by the name used with LINKERSET_DECLARE().
 *              Generally this variable is statically initialized.
 */
#define LINKERSET_ADD_ITEM(_name, _desc_name)                           \
    static void const * XCONCAT_(__, XCONCAT_(_name,                    \
                                            XCONCAT_(_ptr_,             \
                                                    _desc_name)))       \
         __attribute__((section(XSTRING_(_name)),used)) = &_desc_name


/* LINKERSET_ITERATE: Iterate over an entire linkerset.
 *
 *  _name: The name of a linkerset used with LINKERSET_DECLARE().
 *
 *  _var : Used to create a local variable which can be used to access
 *         the data associated with each linkerset member.  The
 *         created variable will be typed as a 'pointer to linkerset
 *         data type', as described above.
 *
 *  _body: Custom code that you want to be executed for each element
 *         in the linkerset.  If more than one statement is needed, a
 *         C block can be supplied.  You may use the '_var' argument
 *         in _body to access fields of the data type in _body.
 */
#define LINKERSET_ITERATE(_name, _var, _body)                   \
    do {                                                        \
        XCONCAT_(_name, _t) **_beg = LINKERSET_START(_name);    \
        XCONCAT_(_name, _t) **_end = LINKERSET_STOP(_name);     \
        while (_beg < _end) {                                   \
            XCONCAT_(_name, _t) *_var = *_beg;                  \
            _body;                                              \
            ++_beg;                                             \
        }                                                       \
    } while (0)


#define LINKERSET_SIZE_PTRDIFF(_name)                   \
    (LINKERSET_STOP(_name) - LINKERSET_START(_name))


/* LINKERSET_SIZE: Produces the number of elements in a linkerset.
 *
 *  _name: The name of a linkerset used with LINKERSET_DECLARE().
 *
 * _type: The desired type of the result.
 *
 * Note: This macro creates a result that is ptrdiff_t, and it may
 *       need further casting to meet size requirements.  Be sure to
 *       test code using this macro on a machine where:
 *
 *          sizeof(size_t) != sizeof(ptrdiff_t)
 *          sizeof(size_t) == sizeof(ptrdiff_t)
 */
#define LINKERSET_SIZE(_name, _type)            \
    (_type)LINKERSET_SIZE_PTRDIFF(_name)


/* LINKERSET_SORT: Sort contents of linkerset using qsort().
 *
 *  _name: The name of a linkerset used with LINKERSET_DECLARE().
 *
 * _compare: A function which will be used as the compare function by
 *           qsort().  Each argument passed to '_compare' will be of
 *           type 'pointer to pointer to linkerset data type'.
 */
#define LINKERSET_SORT(_name, _compare)                                 \
    do {                                                                \
        const size_t n = LINKERSET_SIZE(_name, size_t);                 \
        assert((ptrdiff_t)n ==  /* No truncation! */                    \
               LINKERSET_SIZE_PTRDIFF(_name));                          \
        qsort(LINKERSET_START(_name), n,                                \
              sizeof(LINKERSET_START(_name)), _compare);                \
    } while (0)
#endif
